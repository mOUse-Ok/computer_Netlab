\documentclass[a4paper]{article} 
 \usepackage[left=2cm, right=2cm, top=2cm, bottom=2cm]{geometry} 
 \input{style/ch_xelatex.tex} 
 \input{style/scala.tex} 
 \lstset{frame=, basicstyle={\footnotesize\ttfamily}} 
 \graphicspath{ {images/} } 
 \usepackage{ctex} 
 \usepackage{amsmath} % 用于专业公式排版 
 \usepackage{amsthm} % 引入 amsthm 宏包 
 \usepackage{booktabs} 
 \usepackage{xcolor} 
 \usepackage{colortbl} 
 \usepackage{graphicx} % 引入图片处理宏包 
 \usepackage{listings} 
 \usepackage{caption} 
 \usepackage{xeCJK} % 中文支持（可选） 
 \usepackage{graphicx} % 加载图片宏包 
 %-----------------------------------------BEGIN DOC---------------------------------------- 
 \newtheorem{lemma}{引理} 
 \newtheorem{definition}{定义} 
 \newtheorem{corollary}{推论} 
 \lstset{ 
     language=C++,        
     basicstyle=\small\ttfamily, % 字体大小和类型 
     numbers=left,            % 行号在左侧 
     numberstyle=\tiny,       % 行号字体大小 
     breaklines=true,         % 自动换行 
     frame=single,            % 代码框 
     showstringspaces=false,  % 不显示空格标记 
     commentstyle=\color{gray}, % 注释颜色（需配合xcolor宏包） 
     keywordstyle=\color{blue}\bfseries % 关键字颜色 
 } 
 \begin{document} 
 \renewcommand{\contentsname}{目\ 录} 
 \renewcommand{\appendixname}{附录} 
 \renewcommand{\appendixpagename}{附录} 
 \renewcommand{\refname}{参考文献} 
 \renewcommand{\figurename}{图} 
 \renewcommand{\tablename}{表} 
 \renewcommand{\today}{\number\year 年 \number\month 月 \number\day 日} 
 %-------------------------封面---------------- 
 \begin{titlepage} 
     \begin{center} 
     \includegraphics[width=0.8\textwidth]{NKU.png}\[1cm] 
     \vspace{20mm} 
   \textbf{\huge{\kaishu{计算机网络}}}\[2.3cm] 
   {\fontsize{36pt}{43.2pt}\selectfont\textbf{\kaishu{利用流式套接字编写聊天程序}}}\[1.5cm] % 增加行距和间距 
   \vspace{\fill} 
     \centering 
     \textsc{\LARGE \kaishu{姓名\ :\ 李子恒}}\\[0.5cm] 
     \textsc{\LARGE \kaishu{学号\ :\ 2312114}}\\[0.5cm] 
     \textsc{\LARGE \kaishu{专业\ :\ 密码科学与技术}}\\[0.5cm] 
     \textsc{\LARGE \kaishu{班次\ :\ 0404班}}\\[0.5cm] 
     \vfill 
     {\Large \today} 
     \end{center} 
 \end{titlepage} 
 %-----------------------------------------ABSTRACT-------------------- 
 \begin{abstract} 
     \kaishu{本实验设计并实现了一个基于TCP协议的多人聊天程序，采用客户端-服务器架构，支持多用户实时消息交流。程序使用C++语言编写，具有跨平台兼容性，可在Windows和Linux系统上运行。服务器端采用多线程技术处理并发连接，客户端支持消息发送和接收功能。本报告详细阐述了系统的设计原理、协议规范、核心代码实现、运行方法以及开发过程中遇到的技术挑战与解决方案。通过本次实验，深入理解了网络编程的核心概念和技术，掌握了套接字编程、多线程并发控制和跨平台开发方法。}
 \end{abstract}
 
 \begin{center} 
 \tableofcontents\label{c} 
 \end{center} 
 \newpage 
 %------------------------------------------TEXT-------------------------------------------- 
 
 \section{实验目的与要求} 
 \label{section:purpose} 
 \subsection{实验目的} 
 \begin{enumerate} 
     \item 掌握基于TCP/IP协议的网络编程基本原理 
     \item 学习流式套接字的创建、连接、数据传输和关闭等操作 
     \item 理解客户端-服务器架构的设计与实现方法 
     \item 实现一个具有基本功能的多人聊天系统 
     \item 培养网络应用程序的调试和排错能力 
 \end{enumerate} 
 
 \subsection{实验要求} 
 \begin{enumerate} 
     \item 设计并实现一个聊天协议，支持不同类型的消息传输 
     \item 实现服务器端程序，能够管理多个客户端连接 
     \item 实现客户端程序，提供用户友好的交互界面 
     \item 支持用户登录、登出、广播消息和私聊功能 
     \item 处理异常情况，如网络中断、客户端异常退出等 
     \item 确保系统的稳定性和可靠性 
 \end{enumerate} 
 
 \section{系统总体设计} 
 \label{section:design} 
 \subsection{系统架构} 
 本聊天系统采用典型的客户端-服务器架构，使用TCP协议保证数据传输的可靠性。系统由两个主要部分组成：
 \begin{enumerate} 
     \item \textbf{服务器端}：负责监听客户端连接请求，管理所有在线用户，转发用户消息 
     \item \textbf{客户端}：负责与用户交互，发送用户输入的消息，接收并显示来自服务器的消息 
 \end{enumerate} 
 
 系统架构示意图如下：
 \begin{figure}[h] 
     \centering 
     \caption{聊天系统架构图} 
     \label{fig:architecture} 
     % 这里需要插入架构图，暂时用文字描述代替 
     \begin{minipage}{0.8\textwidth} 
         \centering 
         \begin{tabular}{c} 
             \hline 
             \textbf{客户端1} \\ 
             \hline 
         \end{tabular} 
         \quad \begin{tabular}{c} 
             \textbf{客户端2} \\ 
             \hline 
         \end{tabular} 
         \quad \begin{tabular}{c} 
             \textbf{客户端3} \\ 
             \hline 
         \end{tabular} \\ 
         $\downarrow$ \quad \quad \quad $\downarrow$ \quad \quad \quad $\downarrow$ \\ 
         \begin{tabular}{|c|} 
             \hline 
             \textbf{聊天服务器} \\ 
             \hline 
         \end{tabular} 
     \end{minipage} 
 \end{figure} 
 
 \section{协议设计} 
 \label{section:protocol} 
 \subsection{消息类型} 
 本聊天系统设计了五种不同类型的消息，用于实现各种功能：
 \begin{table}[h] 
     \centering 
     \caption{消息类型定义} 
     \label{tab:message_types} 
     \begin{tabular}{|c|l|l|} 
         \hline 
         \textbf{类型码} & \textbf{消息类型} & \textbf{功能描述} \\ 
         \hline 
         0 & 登录消息 & 客户端向服务器发送登录请求 \ \
         1 & 登出消息 & 客户端向服务器发送登出请求 \\ 
         2 & 广播消息 & 用户向所有在线用户发送消息 \\ 
         3 & 私聊消息 & 用户向特定用户发送私密消息 \\ 
         4 & 系统消息 & 服务器向客户端发送系统通知 \\ 
         \hline 
     \end{tabular} 
 \end{table} 
 
 \subsection{协议语法与语义} 
 \subsubsection{基本格式设计} 
 本系统采用简单直观的文本协议，使用竖线（|）作为字段分隔符。消息格式如下：
 
 \begin{center} 
     \textbf{type|username|message} 
 \end{center} 
 
 这种设计具有以下优点：
 \begin{itemize} 
     \item \textbf{简洁明了}：格式简单，易于解析和实现
     \item \textbf{扩展性好}：可以方便地添加新的消息类型
     \item \textbf{可读性强}：便于调试和问题定位
 \end{itemize} 
 
 其中：
 \begin{itemize} 
     \item \textbf{type}：消息类型代码（0-4）
     \item \textbf{username}：用户名或系统标识
     \item \textbf{message}：消息内容，不同类型的消息有不同的格式
 \end{itemize} 
 
 \subsubsection{消息格式语义} 
 各类消息的具体格式与语义：
 \begin{enumerate} 
     \item \textbf{登录消息}：格式为"0|username|"，客户端发送此消息以加入聊天室
         \begin{itemize}
             \item 字段含义：消息类型0，用户名，空消息体
             \item 处理逻辑：服务器验证用户名，将用户加入在线列表，广播系统通知
         \end{itemize}
     \item \textbf{登出消息}：格式为"1|username|"，客户端发送此消息以离开聊天室
         \begin{itemize}
             \item 字段含义：消息类型1，用户名，空消息体
             \item 处理逻辑：服务器将用户从在线列表移除，广播系统通知，关闭连接
         \end{itemize}
     \item \textbf{广播消息}：格式为"2|username|content"，向所有用户发送公共消息
         \begin{itemize}
             \item 字段含义：消息类型2，发送者用户名，消息内容
             \item 处理逻辑：服务器转发给除发送者外的所有在线用户
         \end{itemize}
     \item \textbf{私聊消息}：格式为"3|sender|target:content"，向特定用户发送私密消息
         \begin{itemize}
             \item 字段含义：消息类型3，发送者用户名，目标用户:消息内容
             \item 处理逻辑：服务器解析目标用户，单独转发给指定用户，并发送确认消息
         \end{itemize}
     \item \textbf{系统消息}：格式为"4|System|content"，服务器发送的系统通知
         \begin{itemize}
             \item 字段含义：消息类型4，系统标识，通知内容
             \item 处理逻辑：客户端以特殊格式显示系统消息
         \end{itemize}
 \end{enumerate} 
 
 \subsection{协议时序} 
 典型的通信时序如下：
 \begin{enumerate} 
     \item 客户端连接到服务器
     \item 客户端发送登录消息（type=0）
     \item 服务器广播用户加入消息（type=4）给所有其他用户
     \item 用户可以发送广播消息（type=2）或私聊消息（type=3）
     \item 服务器根据消息类型进行转发
     \item 客户端发送登出消息（type=1）
     \item 服务器广播用户离开消息（type=4）给所有其他用户
     \item 服务器关闭客户端连接
 \end{enumerate} 
 
 \subsection{协议实现细节} 
 在代码实现中，消息解析采用了以下关键步骤：
 \begin{lstlisting}[caption=服务器消息解析核心代码,label=code:protocol_parse]
 // 解析协议
 char* firstDelim = strchr(buffer, '|');
 if (firstDelim != NULL) {
     int messageType = atoi(buffer);
     char* secondDelim = strchr(firstDelim + 1, '|');
     
     if (secondDelim != NULL) {
         *firstDelim = '\0';  // 分割类型和用户名
         char* username = firstDelim + 1;
         *secondDelim = '\0';  // 分割用户名和内容
         char* content = secondDelim + 1;
         
         // 处理不同类型的消息
         switch (messageType) {
             case 0: // 登录
                 // 处理登录逻辑
                 break;
             case 1: // 登出
                 // 处理登出逻辑
                 break;
             case 2: // 广播消息
                 // 处理广播消息
                 break;
             case 3: // 私聊消息
                 // 处理私聊消息
                 break;
         }
         
         // 恢复分隔符，不影响原缓冲区内容
         *firstDelim = '|';
         *secondDelim = '|';
     }
 }
 \end{lstlisting} 
 
 \subsection{协议创新性} 
 本协议设计在传统聊天协议的基础上进行了以下创新：
 \begin{enumerate} 
     \item \textbf{轻量级设计}：相比IRC等复杂协议，本协议更加轻量，易于实现
     \item \textbf{直观的私聊机制}：使用"@用户名:消息"格式，简化了用户操作
     \item \textbf{双向确认机制}：私聊消息发送后，服务器会向发送者返回确认消息
     \item \textbf{错误处理完善}：包含超时机制和异常连接处理
     \item \textbf{跨平台兼容}：协议设计不依赖特定平台特性，可在不同系统间通信
 \end{enumerate} 
 
 这种设计既保持了协议的简洁性，又确保了功能的完整性和系统的可靠性。 
 
 \section{核心代码实现} 
 \label{section:implementation} 
 \subsection{服务器端实现} 
 \subsubsection{数据结构设计} 
 服务器端使用以下核心数据结构来管理客户端连接和状态：
 
 \begin{lstlisting}[caption=客户端信息结构,label=code:client_info]
 // 客户端信息结构
 typedef struct {
     SocketType socket;          // 客户端套接字
     char username[50];          // 客户端用户名
     struct sockaddr_in address; // 客户端网络地址
 } ClientInfo;
 
 // 全局变量
 std::vector<ClientInfo*> clients; // 存储所有连接的客户端
 CRITICAL_SECTION clientsMutex;    // Windows平台的互斥锁，保证线程安全
 bool serverRunning;               // 服务器运行状态标志
 \end{lstlisting} 
 
 	extbf{数据结构分析：}
 \begin{itemize}
     \item 	extbf{ClientInfo结构体}：封装了单个客户端的完整信息，包括通信套接字、用户名和网络地址，便于统一管理
     \item 	extbf{clients向量}：动态管理所有在线客户端，支持添加、删除和遍历操作
     \item 	extbf{clientsMutex互斥锁}：在多线程环境下保护共享资源clients向量，避免数据竞争
     \item 	extbf{serverRunning标志}：控制服务器主循环，用于优雅关闭服务器
 \end{itemize}
 
 \subsubsection{跨平台兼容设计} 
 系统采用条件编译实现了Windows和Linux平台的兼容性：
 
 \begin{lstlisting}[caption=跨平台兼容性定义,label=code:cross_platform]
 #ifdef _WIN32
     #include <WinSock2.h>
     #include <WS2tcpip.h>
     #include <process.h> // _beginthreadex
     #include <windows.h> // SetConsoleOutputCP, SetConsoleCP
     #pragma comment(lib, "ws2_32.lib")
     typedef SOCKET SocketType;
     #define INVALID_SOCKET_VALUE INVALID_SOCKET
     #define CLOSE_SOCKET(s) closesocket(s)
     typedef unsigned (__stdcall *ThreadFunction)(void*);
     #define CREATE_THREAD(func, arg) _beginthreadex(NULL, 0, (ThreadFunction)func, arg, 0, NULL)
 #else
     #include <sys/socket.h>
     #include <netinet/in.h>
     #include <arpa/inet.h>
     #include <unistd.h>
     #include <fcntl.h>
     #include <errno.h>
     #include <pthread.h>
     typedef int SocketType;
     #define INVALID_SOCKET_VALUE -1
     #define CLOSE_SOCKET(s) close(s)
     #define CREATE_THREAD(func, arg) pthread_create(NULL, NULL, func, arg)
 #endif
 \end{lstlisting}
 
 	extbf{设计分析：}
 \begin{itemize}
     \item 通过类型别名（如SocketType）抽象平台差异，统一代码风格
     \item 使用宏定义封装不同平台的API调用，简化代码复杂度
     \item 对线程创建、套接字操作等平台相关功能进行封装，提供一致的接口
 \end{itemize}
 
 \subsubsection{核心函数功能分析} 
 
 \paragraph{1. 初始化函数} 
 \begin{lstlisting}[caption=初始化Winsock,label=code:init_winsock]
 bool initializeWinsock() {
 #ifdef _WIN32
     WSADATA wsaData;
     if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
         printError("WSAStartup failed");
         return false;
     }
     
     // 设置控制台为UTF-8编码，支持中文显示
     SetConsoleOutputCP(CP_UTF8);
     SetConsoleCP(CP_UTF8);
     
     InitializeCriticalSection(&clientsMutex);
 #else
     pthread_mutex_init(&clientsMutex, NULL);
 #endif
     return true;
 }
 \end{lstlisting}
 
 	extbf{功能分析：}
 \begin{itemize}
     \item 在Windows平台初始化Winsock库，指定使用2.2版本
     \item 配置控制台编码为UTF-8，确保中文消息正确显示
     \item 初始化线程同步原语（互斥锁），为多线程操作做准备
     \item 返回初始化是否成功，便于主函数进行错误处理
 \end{itemize}
 
 \paragraph{2. 消息发送函数} 
 \begin{lstlisting}[caption=发送消息给客户端,label=code:send_client]
 bool sendToClient(const ClientInfo* client, const char* message) {
 #ifdef _WIN32
     if (send(client->socket, message, strlen(message), 0) == SOCKET_ERROR) {
         printError("Send failed");
         return false;
     }
 #else
     if (send(client->socket, message, strlen(message), 0) == -1) {
         printError("Send failed");
         return false;
     }
 #endif
     return true;
 }
 \end{lstlisting}
 
 \begin{lstlisting}[caption=广播消息函数,label=code:broadcast]
 void broadcastMessage(const char* message, const char* senderUsername) {
     lockMutex(); // 加锁保护共享资源
     for (size_t i = 0; i < clients.size(); ++i) {
         if (strcmp(clients[i]->username, senderUsername) != 0) {
             sendToClient(clients[i], message);
         }
     }
     unlockMutex(); // 释放锁
 }
 \end{lstlisting}
 
 	extbf{功能分析：}
 \begin{itemize}
     \item 	extbf{sendToClient}：封装了向单个客户端发送消息的逻辑，处理平台差异，返回发送结果
     \item 	extbf{broadcastMessage}：实现消息广播功能，遍历所有客户端并发送消息
     \item 使用互斥锁确保在多线程环境下对clients向量的安全访问
     \item 消息不会发送回原始发送者，避免消息回显
 \end{itemize}
 
 \paragraph{3. 私聊消息处理} 
 \begin{lstlisting}[caption=私聊消息处理函数,label=code:private_message]
 void handlePrivateMessage(const char* message, const char* senderUsername) {
     // 解析目标用户名，格式为"targetUsername:messageContent"
     const char* colonPos = strchr(message, ':');
     if (colonPos != NULL) {
         char targetUsername[50];
         strncpy(targetUsername, message, colonPos - message);
         targetUsername[colonPos - message] = '\0';
         
         const char* actualMessage = colonPos + 1;
         bool userFound = false;
         
         // 查找并发送给目标用户
         lockMutex();
         for (size_t i = 0; i < clients.size(); ++i) {
             if (strcmp(clients[i]->username, targetUsername) == 0) {
                 char privateMsg[1024];
                 sprintf(privateMsg, "3|%s|%s", senderUsername, actualMessage);
                 sendToClient(clients[i], privateMsg);
                 userFound = true;
                 break;
             }
         }
         unlockMutex();
         
         // 向发送者发送确认消息
         lockMutex();
         for (size_t i = 0; i < clients.size(); ++i) {
             if (strcmp(clients[i]->username, senderUsername) == 0) {
                 char confirmMsg[1024];
                 if (userFound) {
                     sprintf(confirmMsg, "4|System|私聊消息已发送给 %s", targetUsername);
                 } else {
                     sprintf(confirmMsg, "4|System|用户 %s 不存在或不在线", targetUsername);
                 }
                 sendToClient(clients[i], confirmMsg);
                 break;
             }
         }
         unlockMutex();
     }
 }
 \end{lstlisting}
 
 	extbf{功能分析：}
 \begin{itemize}
     \item 解析消息格式，提取目标用户名和实际消息内容
     \item 遍历客户端列表查找目标用户，如存在则发送私聊消息
     \item 无论目标用户是否存在，都向发送者发送状态确认消息
     \item 使用互斥锁保护对clients向量的并发访问
     \item 实现了私聊消息的可靠传递和状态反馈机制
 \end{itemize}
 
 \paragraph{4. 客户端处理线程} 
 \begin{lstlisting}[caption=客户端处理线程,label=code:handle_client]
 unsigned __stdcall handleClientThread(void* arg) {
     ClientInfo* client = (ClientInfo*)arg;
     char buffer[1024];
     bool connected = true;
     
     while (connected && serverRunning) {
         // 接收消息
         int bytesRead = recv(client->socket, buffer, sizeof(buffer) - 1, 0);
         
         // 错误处理和连接断开检测
         #ifdef _WIN32
         if (bytesRead == SOCKET_ERROR) {
             int errorCode = WSAGetLastError();
             if (errorCode == WSAEWOULDBLOCK) {
                 // 非阻塞模式下没有数据可读，继续尝试
                 Sleep(10);
                 continue;
             } else {
                 printError("Recv failed");
                 connected = false;
                 break;
             }
         } else if (bytesRead == 0) {
             printf("%s 断开连接\n", client->username);
             connected = false;
             break;
         }
         #else
         // Linux平台错误处理...
         #endif
         
         // 确保消息以null结尾
         buffer[bytesRead] = '\0';
         
         // 解析协议并处理不同类型的消息
         // ...
     }
     
     // 清理资源：移除客户端并关闭连接
     lockMutex();
     for (size_t i = 0; i < clients.size(); ++i) {
         if (strcmp(clients[i]->username, client->username) == 0) {
             clients.erase(clients.begin() + i);
             break;
         }
     }
     unlockMutex();
     
     CLOSE_SOCKET(client->socket);
     delete client;
     
     return 0;
 }
 \end{lstlisting}
 
 	extbf{功能分析：}
 \begin{itemize}
     \item 为每个客户端连接创建独立线程，实现并发处理
     \item 循环接收客户端消息，处理各种异常情况
     \item 实现协议解析，根据消息类型调用相应处理函数
     \item 连接关闭时清理资源，从客户端列表中移除
     \item 支持非阻塞模式，提高系统响应性
 \end{itemize}
 
 \subsection{客户端实现} 
 \subsubsection{核心功能模块} 
 
 \paragraph{1. 非阻塞连接实现} 
 \begin{lstlisting}[caption=客户端非阻塞连接,label=code:nonblocking_connect]
 // 设置套接字为非阻塞模式
 u_long mode = 1; // 非阻塞模式
 ioctlsocket(clientSocket, FIONBIO, &mode);
 
 // 连接服务器
 if (connect(clientSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
     int errorCode = WSAGetLastError();
     if (errorCode != WSAEWOULDBLOCK && errorCode != WSAEINPROGRESS) {
         printError("Connect failed");
         // 错误处理...
     }
     
     // 使用select等待连接完成，设置超时
     fd_set writeSet;
     FD_ZERO(&writeSet);
     FD_SET(clientSocket, &writeSet);
     
     struct timeval timeout;
     timeout.tv_sec = 5;
     timeout.tv_usec = 0;
     
     if (select(0, NULL, &writeSet, NULL, &timeout) <= 0) {
         printError("Connect timeout");
         // 超时处理...
     }
     
     // 检查连接是否真正成功
     int optval;
     int optlen = sizeof(optval);
     if (getsockopt(clientSocket, SOL_SOCKET, SO_ERROR, (char*)&optval, &optlen) < 0 || optval != 0) {
         printError("Connect failed");
         // 错误处理...
     }
 }
 \end{lstlisting}
 
 	extbf{功能分析：}
 \begin{itemize}
     \item 将客户端套接字设置为非阻塞模式，避免连接操作阻塞主线程
     \item 使用select函数实现带超时的连接等待，增强程序健壮性
     \item 连接完成后检查SO_ERROR选项，确保连接真正成功
     \item 设置5秒超时，防止程序无限等待
     \item 这种方式比阻塞连接提供更好的用户体验和错误恢复能力
 \end{itemize}
 
 \paragraph{2. 消息接收线程} 
 \begin{lstlisting}[caption=客户端消息接收线程,label=code:receive_thread]
 unsigned __stdcall receiveMessagesThread(void* arg) {
     char buffer[1024];
     
     while (clientRunning) {
         // 接收消息
         int bytesRead = recv(clientSocket, buffer, sizeof(buffer) - 1, 0);
         
         // 处理各种接收情况
         #ifdef _WIN32
         if (bytesRead == SOCKET_ERROR) {
             int errorCode = WSAGetLastError();
             if (errorCode == WSAEWOULDBLOCK) {
                 Sleep(10);
                 continue;
             } else if (errorCode == WSAECONNABORTED || errorCode == WSAECONNRESET) {
                 printMessage("连接已断开\n");
                 clientRunning = false;
                 break;
             } else {
                 printError("Recv failed");
                 clientRunning = false;
                 break;
             }
         } else if (bytesRead == 0) {
             printMessage("服务器已关闭连接\n");
             clientRunning = false;
             break;
         }
         #endif
         
         // 确保消息以null结尾
         buffer[bytesRead] = '\0';
         
         // 解析协议并显示不同类型的消息
         char* firstDelim = strchr(buffer, '|');
         if (firstDelim != NULL) {
             int messageType = atoi(buffer);
             char* secondDelim = strchr(firstDelim + 1, '|');
             
             if (secondDelim != NULL) {
                 *firstDelim = '\0';
                 char* senderName = firstDelim + 1;
                 *secondDelim = '\0';
                 char* content = secondDelim + 1;
                 
                 // 根据消息类型显示不同格式
                 switch (messageType) {
                     case 2: // 广播消息
                         printMessage("%s: %s\n", senderName, content);
                         break;
                     case 3: // 私聊消息
                         printMessage("[私聊] %s: %s\n", senderName, content);
                         break;
                     case 4: // 系统消息
                         printMessage("[系统] %s\n", content);
                         break;
                 }
                 
                 // 恢复分隔符
                 *firstDelim = '|';
                 *secondDelim = '|';
             }
         }
     }
 }
 \end{lstlisting}
 
 	extbf{功能分析：}
 \begin{itemize}
     \item 创建独立线程专门接收服务器消息，避免阻塞用户输入
     \item 处理各种网络异常情况（连接断开、重置等）
     \item 实现协议解析，根据消息类型以不同格式显示
     \item 使用线程安全的printMessage函数输出消息，避免显示混乱
     \item 非阻塞模式下适当休眠，减少CPU占用
 \end{itemize}
 
 \paragraph{3. 用户输入处理} 
 \begin{lstlisting}[caption=用户输入处理,label=code:handle_input]
 while (clientRunning) {
     char message[1024];
     if (fgets(message, sizeof(message), stdin) == NULL) {
         break; // 处理输入错误
     }
     message[strcspn(message, "\n")] = '\0';  // 移除换行符
     
     // 命令处理逻辑
     if (strcmp(message, "/quit") == 0) {
         // 退出命令处理
         char logoutMsg[1024];
         sprintf(logoutMsg, "1|%s|", username);
         sendToServer(logoutMsg);
         
         clientRunning = false;
         break;
     } else if (message[0] == '@') {
         // 私聊命令处理
         char* colonPos = strchr(message, ':');
         if (colonPos != NULL && colonPos > message + 1) {
             // 格式检查通过，发送私聊消息
             char privateMsg[1024];
             sprintf(privateMsg, "3|%s|%s", username, message + 1); // 去掉@符号
             sendToServer(privateMsg);
         } else {
             printMessage("私聊格式: @用户名:消息\n");
         }
     } else {
         // 广播消息处理
         char broadcastMsg[1024];
         sprintf(broadcastMsg, "2|%s|%s", username, message);
         sendToServer(broadcastMsg);
     }
 }
 \end{lstlisting}
 
 	extbf{功能分析：}
 \begin{itemize}
     \item 主循环处理用户输入，支持三种操作模式
     \item 识别退出命令（/quit），发送登出消息并关闭连接
     \item 识别私聊命令（@用户名:消息），格式检查后发送私聊消息
     \item 普通消息作为广播消息发送给所有用户
     \item 提供友好的错误提示，帮助用户正确使用命令
 \end{itemize}
 
 \subsubsection{线程安全设计} 
 客户端实现了线程安全的输出机制，避免多线程并发输出导致的显示混乱：
 
 \begin{lstlisting}[caption=线程安全的消息输出,label=code:thread_safe_output]
 // 输出线程安全的消息
 void printMessage(const char* format, ...) {
     va_list args;
     va_start(args, format);
     
 #ifdef _WIN32
     EnterCriticalSection(&coutMutex);
     vprintf(format, args);
     LeaveCriticalSection(&coutMutex);
 #else
     pthread_mutex_lock(&coutMutex);
     vprintf(format, args);
     pthread_mutex_unlock(&coutMutex);
 #endif
     
     va_end(args);
 }
 \end{lstlisting}
 
 	extbf{设计分析：}
 \begin{itemize}
     \item 使用变参函数实现灵活的格式化输出
     \item 通过互斥锁保护标准输出，确保消息完整性
     \item 跨平台实现，在Windows和Linux上都能正常工作
     \item 避免了主线程和接收线程同时输出导致的混乱显示
 \end{itemize} 
 
 \section{程序运行与测试} 
 \label{section:running} 
 \subsection{运行环境要求} 
 本聊天程序可以在以下环境中运行：
 \begin{itemize}
     \item Windows系统：需要Visual Studio或MinGW环境，支持C++11及以上标准
     \item Linux系统：需要GCC编译器，支持C++11及以上标准
     \item 网络环境：程序使用TCP/IP协议族，需要确保网络连接正常
     \item 依赖库：Windows平台依赖Winsock2库，Linux平台依赖pthread和socket相关库
 \end{itemize}
 
 \subsection{程序编译说明} 
 \subsubsection{Windows平台编译} 
 在Windows平台上，可以使用Visual Studio或MinGW进行编译：
 \begin{lstlisting}[caption=Windows平台编译命令,label=code:compile_windows]
 # 使用MinGW编译
 g++ server.cpp -o server.exe -lpthread
 g++ client.cpp -o client.exe -lpthread -lws2_32
 
 # 或者在Visual Studio中创建项目并添加相应的源文件
 \end{lstlisting}
 
 \subsubsection{Linux平台编译} 
 在Linux平台上，使用GCC编译器编译：
 \begin{lstlisting}[caption=Linux平台编译命令,label=code:compile_linux]
 # 编译服务器端
 g++ server.cpp -o server -lpthread
 
 # 编译客户端
 g++ client.cpp -o client -lpthread
 \end{lstlisting}
 
 \subsection{运行步骤} 
 要启动聊天系统，需要按照以下步骤操作：
 
 \paragraph{1. 启动服务器} 
 \begin{enumerate}
     \item 打开命令行终端
     \item 切换到编译生成的可执行文件目录
     \item 运行服务器程序：
     \begin{lstlisting}
 # Windows
 server.exe
 
 # Linux
 ./server
     \end{lstlisting}
     \item 服务器启动成功后，会显示监听端口信息，等待客户端连接
 \end{enumerate}
 
 \paragraph{2. 启动客户端} 
 \begin{enumerate}
     \item 打开新的命令行终端（可以在多台计算机上运行）
     \item 切换到编译生成的可执行文件目录
     \item 运行客户端程序：
     \begin{lstlisting}
 # Windows
 client.exe
 
 # Linux
 ./client
     \end{lstlisting}
     \item 按照提示输入用户名进行登录
     \item 登录成功后，可以开始发送和接收消息
 \end{enumerate}
 
 \subsection{界面展示与交互说明} 
 \subsubsection{服务器界面} 
 服务器端界面简洁，主要用于显示连接状态和日志信息：
 
 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.8\textwidth]{images/server_interface.png}
     \caption{服务器端运行界面}
     \label{fig:server_interface}
 \end{figure}
 
 服务器界面主要显示以下信息：
 \begin{itemize}
     \item 服务器启动信息
     \item 客户端连接/断开事件
     \item 系统日志和错误信息
     \item 客户端登录和退出状态
 \end{itemize}
 
 \subsubsection{客户端界面} 
 客户端界面为命令行交互方式，具有清晰的消息显示格式：
 
 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.8\textwidth]{images/client_interface.png}
     \caption{客户端运行界面}
     \label{fig:client_interface}
 \end{figure}
 
 客户端界面特点：
 \begin{itemize}
     \item 区分不同类型消息（广播、私聊、系统消息）
     \item 私聊消息以"[私聊]"前缀标识
     \item 系统消息以"[系统]"前缀标识
     \item 用户输入区域在界面底部
 \end{itemize}
 
 \subsection{使用方法} 
 客户端支持以下命令和操作：
 
 \begin{table}[htbp]
     \centering
     \begin{tabular}{|l|l|l|}
     \hline
     \textbf{操作类型} & \textbf{命令格式} & \textbf{说明} \\ \hline
     广播消息 & 直接输入消息内容 & 向所有在线用户发送消息 \\ \hline
     私聊消息 & @用户名:消息内容 & 向指定用户发送私密消息 \\ \hline
     退出系统 & /quit & 安全退出聊天系统 \\ \hline
     \end{tabular}
     \caption{客户端操作命令表}
     \label{tab:client_commands}
 \end{table}
 
 \subsubsection{操作示例} 
 \paragraph{发送广播消息} 
 用户直接输入消息内容，按回车键发送：
 \begin{lstlisting}
 大家好！
 \end{lstlisting}
 
 其他用户将看到：
 \begin{lstlisting}
 用户名: 大家好！
 \end{lstlisting}
 
 \paragraph{发送私聊消息} 
 使用@符号后跟用户名和冒号格式：
 \begin{lstlisting}
 @张三:你好，这是一条私聊消息
 \end{lstlisting}
 
 接收者将看到：
 \begin{lstlisting}
 [私聊] 发送者名:你好，这是一条私聊消息
 \end{lstlisting}
 
 \paragraph{退出系统} 
 输入/quit命令退出：
 \begin{lstlisting}
 /quit
 \end{lstlisting}
 
 系统将向其他用户广播当前用户退出的消息。
 
 \subsection{运行逻辑分析} 
 \subsubsection{正常运行流程} 
 1. \textbf{启动阶段}：
    - 服务器初始化Winsock库，创建套接字并绑定到指定端口
    - 服务器开始监听连接请求
    - 客户端初始化Winsock库，创建套接字
    - 客户端尝试连接服务器
 
 2. \textbf{连接阶段}：
    - 客户端连接成功后，输入用户名进行登录
    - 服务器为每个客户端创建单独的处理线程
    - 服务器广播新用户加入的系统消息
 
 3. \textbf{通信阶段}：
    - 用户可以发送广播或私聊消息
    - 服务器根据消息类型进行转发
    - 客户端实时接收并显示消息
 
 4. \textbf{退出阶段}：
    - 用户输入/quit命令退出
    - 客户端发送登出消息给服务器
    - 服务器移除客户端信息并广播退出消息
    - 相关线程和套接字资源被释放
 
 \subsubsection{异常处理机制} 
 程序实现了完善的异常处理机制，确保在各种异常情况下能够正常工作：
 \begin{itemize}
     \item \textbf{连接超时处理}：客户端使用非阻塞连接并设置超时，防止无限等待
     \item \textbf{断线重连提示}：当连接断开时，客户端会收到明确的提示信息
     \item \textbf{无效命令处理}：对用户输入的无效命令提供友好的错误提示
     \item \textbf{资源清理保证}：无论程序如何退出，都会释放所有分配的资源
     \item \textbf{消息格式校验}：对接收的消息进行格式校验，防止异常消息导致程序崩溃
 \end{itemize}
 
 \subsection{功能测试} 
 \subsubsection{基本功能测试} 
 \begin{enumerate}
     \item \textbf{用户登录/退出}：测试用户能否正常登录和退出系统
     \item \textbf{广播消息}：验证广播消息能否发送给所有在线用户
     \item \textbf{私聊功能}：测试私聊消息能否正确发送给指定用户
     \item \textbf{多客户端并发}：测试多个客户端同时连接和通信的稳定性
 \end{enumerate}
 
 \subsubsection{异常情况测试} 
 \begin{enumerate}
     \item \textbf{服务器关闭}：测试当服务器异常关闭时，客户端能否正确响应
     \item \textbf{网络中断}：测试网络临时中断后重新连接的情况
     \item \textbf{用户名冲突}：测试多个用户使用相同用户名的处理
     \item \textbf{大量消息发送}：测试短时间内发送大量消息的系统稳定性
 \end{enumerate} 
 \section{实验过程中遇到的问题及分析} 
 \label{section:problems}
 
 \subsection{遇到的主要问题} 
 
 \subsubsection{1. 跨平台兼容性问题} 
 \paragraph{问题描述}：
 在开发过程中，首先遇到的是Windows和Linux平台之间的API差异问题。Windows平台使用Winsock2库进行套接字编程，而Linux平台使用POSIX socket API。这种差异导致了代码无法在两个平台上直接编译。
 
 \paragraph{问题分析}：
 两个平台在套接字创建、初始化、错误处理和线程管理等方面存在显著差异：
 \begin{itemize}
     \item Windows使用SOCKET类型，Linux使用int类型
     \item Windows使用WSAStartup()初始化网络库，Linux不需要
     \item 错误代码获取方式不同（WSAGetLastError vs errno）
     \item 线程创建API不同（_beginthreadex vs pthread_create）
 \end{itemize}
 
 \paragraph{解决方案}：
 采用条件编译和宏定义的方式解决跨平台问题：
 \begin{lstlisting}
 #ifdef _WIN32
     // Windows平台代码
 #else
     // Linux平台代码
 #endif
 
 // 使用类型别名和宏封装平台差异
 typedef SOCKET SocketType;  // Windows
 // typedef int SocketType;  // Linux
 
 #define INVALID_SOCKET_VALUE INVALID_SOCKET  // Windows
 // #define INVALID_SOCKET_VALUE -1  // Linux
 
 #define CLOSE_SOCKET(s) closesocket(s)  // Windows
 // #define CLOSE_SOCKET(s) close(s)  // Linux
 \end{lstlisting}
 
 \paragraph{经验总结}：
 跨平台开发应尽早考虑平台差异，使用抽象层封装不同平台的API，采用统一的接口进行开发，这样可以大幅提高代码的可移植性和维护性。
 
 \subsubsection{2. 线程同步问题} 
 \paragraph{问题描述}：
 在实现多客户端并发处理时，出现了数据竞争问题。多个线程同时访问和修改clients向量，导致程序崩溃或数据不一致。
 
 \paragraph{问题分析}：
 服务器为每个客户端创建一个独立的线程，这些线程共享clients向量。当多个线程同时添加、删除或遍历clients时，如果没有适当的同步机制，就会导致内存访问冲突。
 
 \paragraph{解决方案}：
 实现线程同步机制，使用互斥锁保护共享资源：
 \begin{lstlisting}
 // 定义互斥锁
 #ifdef _WIN32
     CRITICAL_SECTION clientsMutex;
 #else
     pthread_mutex_t clientsMutex;
 #endif
 
 // 初始化互斥锁
 InitializeCriticalSection(&clientsMutex);  // Windows
 // pthread_mutex_init(&clientsMutex, NULL);  // Linux
 
 // 访问共享资源前加锁
 void lockMutex() {
 #ifdef _WIN32
     EnterCriticalSection(&clientsMutex);
 #else
     pthread_mutex_lock(&clientsMutex);
 #endif
 }
 
 // 访问完成后解锁
 void unlockMutex() {
 #ifdef _WIN32
     LeaveCriticalSection(&clientsMutex);
 #else
     pthread_mutex_unlock(&clientsMutex);
 #endif
 }
 \end{lstlisting}
 
 所有对clients向量的操作都被严格限制在锁的保护范围内，确保同一时间只有一个线程可以修改共享数据。
 
 \paragraph{经验总结}：
 多线程编程中，必须为所有共享资源提供同步机制。应尽量减小临界区范围，避免长时间持有锁，以提高程序的并发性能。
 
 \subsubsection{3. 消息格式解析问题} 
 \paragraph{问题描述}：
 在实现协议解析时，当接收到不完整或格式错误的消息时，程序可能会产生未定义行为或崩溃。
 
 \paragraph{问题分析}：
 原始代码假设所有接收到的消息都符合预定格式，缺乏必要的边界检查和错误处理。如果消息格式不符合预期（如分隔符缺失），就会导致指针操作错误。
 
 \paragraph{解决方案}：
 增强消息解析的健壮性，添加严格的边界检查和错误处理：
 \begin{lstlisting}
 // 更安全的消息解析代码
 char* firstDelim = strchr(buffer, '|');
 if (firstDelim != NULL) {
     int messageType = atoi(buffer);
     char* secondDelim = strchr(firstDelim + 1, '|');
     
     if (secondDelim != NULL) {
         // 安全地解析数据
         *firstDelim = '\0';
         char* senderName = firstDelim + 1;
         *secondDelim = '\0';
         char* content = secondDelim + 1;
         
         // 处理消息...
         
         // 恢复分隔符
         *firstDelim = '|';
         *secondDelim = '|';
     } else {
         // 格式错误处理
         printf("警告: 接收到格式错误的消息\n");
     }
 }
 \end{lstlisting}
 
 \paragraph{经验总结}：
 网络编程中，永远不能信任从网络接收到的数据。必须实现严格的输入验证和错误处理，确保程序在面对恶意或意外数据时仍能稳定运行。
 
 \subsubsection{4. 非阻塞IO与超时处理问题} 
 \paragraph{问题描述}：
 初始版本使用阻塞式IO，导致在网络延迟或连接失败时程序长时间无响应，用户体验较差。
 
 \paragraph{问题分析}：
 阻塞式IO在等待网络操作完成时会挂起线程，特别是在连接建立和数据接收过程中，可能导致程序假死。
 
 \paragraph{解决方案}：
 采用非阻塞IO模式并实现超时机制：
 \begin{lstlisting}
 // 设置套接字为非阻塞模式
 u_long mode = 1;
 ioctlsocket(clientSocket, FIONBIO, &mode);
 
 // 使用select设置超时
 fd_set writeSet;
 FD_ZERO(&writeSet);
 FD_SET(clientSocket, &writeSet);
 
 struct timeval timeout;
 timeout.tv_sec = 5;  // 5秒超时
 timeout.tv_usec = 0;
 
 int result = select(0, NULL, &writeSet, NULL, &timeout);
 if (result <= 0) {
     // 处理超时或错误
     printf("连接超时\n");
 }
 \end{lstlisting}
 
 \paragraph{经验总结}：
 在网络应用中，合理使用非阻塞IO和超时机制是提高程序响应性和用户体验的关键。特别是对于需要同时处理多个连接的服务器程序，非阻塞IO几乎是必不可少的选择。
 
 \subsubsection{5. 中文字符显示问题} 
 \paragraph{问题描述}：
 在Windows平台上，控制台默认不支持UTF-8编码，导致中文消息显示为乱码。
 
 \paragraph{问题分析}：
 Windows控制台默认使用系统编码（通常是GBK），而程序中使用UTF-8编码发送和接收消息，编码不一致导致显示异常。
 
 \paragraph{解决方案}：
 在程序初始化时设置控制台为UTF-8编码：
 \begin{lstlisting}
 #ifdef _WIN32
     // 设置控制台为UTF-8编码
     SetConsoleOutputCP(CP_UTF8);
     SetConsoleCP(CP_UTF8);
 #endif
 \end{lstlisting}
 
 \paragraph{经验总结}：
 在处理国际化字符时，必须统一编码标准（通常选择UTF-8），并确保所有输入输出接口都正确配置为相应的编码格式。
 
 \subsection{实验总结与思考} 
 
 \subsubsection{收获与体会} 
 通过本次网络聊天程序的开发，我收获了以下经验：
 
 1. **网络编程基础**：深入理解了TCP/IP协议、套接字编程模型和网络通信的基本原理。
 
 2. **多线程编程**：掌握了多线程并发控制、线程同步和资源共享等关键技术。
 
 3. **跨平台开发**：学会了如何处理不同操作系统之间的API差异，提高代码的可移植性。
 
 4. **错误处理与健壮性**：认识到在网络编程中实现完善的错误处理和异常恢复机制的重要性。
 
 5. **协议设计**：理解了设计简单而有效的应用层协议的基本原则和方法。
 
 \subsubsection{改进方向} 
 虽然当前系统已经实现了基本功能，但仍有以下改进空间：
 
 1. **用户认证机制**：添加用户名密码验证，提高系统安全性。
 
 2. **消息历史记录**：实现聊天记录存储和查询功能。
 
 3. **图形用户界面**：开发基于GUI的客户端，提供更好的用户体验。
 
 4. **文件传输功能**：扩展系统支持文件共享和传输。
 
 5. **服务器集群**：优化服务器架构，支持高并发和分布式部署。
 
 6. **加密通信**：实现消息加密，保护用户隐私和通信安全。
 
 \subsubsection{对网络编程的思考} 
 网络编程是一项复杂而富有挑战性的工作，成功的网络应用需要考虑以下几个关键方面：
 
 1. **可靠性**：网络是不可靠的，必须设计能够处理各种异常情况的健壮系统。
 
 2. **安全性**：网络通信容易受到攻击，需要实现适当的安全机制。
 
 3. **性能**：随着用户数量增加，系统性能会受到挑战，需要优化算法和架构。
 
 4. **可扩展性**：系统设计应考虑未来的功能扩展和性能提升需求。
 
 5. **用户体验**：即使在网络条件不佳的情况下，也应尽量提供流畅的用户体验。
 
 通过本次实验，我深刻认识到理论知识与实践相结合的重要性。只有通过实际编程，才能真正掌握网络编程的精髓，理解各种技术选择的利弊，并在面对实际问题时做出合理的决策。
 
 \textbf{Windows平台（使用MinGW）：}
 \begin{lstlisting}
 g++ server.cpp -o server.exe -lws2_32
 g++ client.cpp -o client.exe -lws2_32
 \end{lstlisting} 
 
 \textbf{Linux平台：}
 \begin{lstlisting}
 g++ server.cpp -o server -lpthread
 g++ client.cpp -o client -lpthread
 \end{lstlisting} 
 
 \subsection{程序运行} 
 \subsubsection{启动服务器} 
 1. 在命令行中运行服务器程序：
 \begin{lstlisting}
 ./server  # Linux
 server.exe  # Windows
 \end{lstlisting}
 
 2. 服务器启动成功后，会显示：
 \begin{lstlisting}
 服务器启动成功，监听端口 8888...
 输入 /quit 停止服务器
 \end{lstlisting}
 
 \subsubsection{启动客户端} 
 1. 在另一个命令行窗口中运行客户端程序：
 \begin{lstlisting}
 ./client  # Linux
 client.exe  # Windows
 \end{lstlisting}
 
 2. 连接成功后，输入用户名登录聊天室：
 \begin{lstlisting}
 连接服务器成功！
 请输入您的用户名: Alice
 欢迎来到聊天室！
 输入 /quit 退出聊天室，输入 @用户名:消息 发送私聊
 \end{lstlisting}
 
 \subsection{功能测试} 
 \subsubsection{广播消息测试} 
 用户可以直接输入消息内容发送广播消息：
 \begin{lstlisting}
 Alice: 大家好！
 Bob: 你好，Alice！
 \end{lstlisting}
 
 \subsubsection{私聊消息测试} 
 用户可以使用@用户名:消息格式发送私聊：
 \begin{lstlisting}
 @Bob: 这是一条私聊消息
 [系统] 私聊消息已发送给 Bob
 [私聊] Bob: 收到你的私聊消息
 \end{lstlisting}
 
 \subsubsection{用户登录/登出测试} 
 当用户登录或登出时，系统会发送通知：
 \begin{lstlisting}
 [系统] Alice 加入了聊天室
 [系统] Bob 离开了聊天室
 \end{lstlisting}
 
 \subsection{运行界面展示} 
 \begin{figure}[h]
     \centering
     \caption{服务器运行界面}
     \label{fig:server_ui}
     % 这里需要插入服务器运行界面截图
     \begin{minipage}{0.9\textwidth}
         \begin{lstlisting}[basicstyle=\tiny\ttfamily,frame=single]
 服务器启动成功，监听端口 8888...
 输入 /quit 停止服务器
 Alice 加入聊天室
 Bob 加入聊天室
 Alice: 大家好！
 Bob: 你好，Alice！
 Alice 退出聊天室
         \end{lstlisting}
     \end{minipage}
 \end{figure}
 
 \begin{figure}[h]
     \centering
     \caption{客户端（Alice）运行界面}
     \label{fig:client_alice}
     % 这里需要插入客户端运行界面截图
     \begin{minipage}{0.9\textwidth}
         \begin{lstlisting}[basicstyle=\tiny\ttfamily,frame=single]
 连接服务器成功！
 请输入您的用户名: Alice
 欢迎来到聊天室！
 输入 /quit 退出聊天室，输入 @用户名:消息 发送私聊
 [系统] Bob 加入了聊天室
 大家好！
 Bob: 你好，Alice！
 /quit
 已退出聊天室
         \end{lstlisting}
     \end{minipage}
 \end{figure}
 
 \section{实验总结与体会} 
 \label{section:conclusion}

 本次实验成功实现了基于流式套接字的多人聊天程序，涵盖了网络编程的核心概念和技术。通过项目的开发，我深入理解了TCP/IP协议的工作原理、套接字编程模型、多线程并发控制和跨平台开发技术。
 
 主要收获包括：
 \begin{enumerate}
     \item 掌握了基于TCP协议的网络通信实现方法
     \item 理解了服务器-客户端架构的设计与实现
     \item 学会了使用多线程技术处理并发连接
     \item 实现了跨平台兼容性设计
     \item 设计并实现了简单高效的应用层协议
     \item 培养了问题分析和解决能力
 \end{enumerate}
 
 本聊天程序虽然功能简单，但已经具备了实用的多人实时通信能力。未来可以通过添加用户认证、消息加密、文件传输和图形界面等功能，进一步提升系统的实用性和用户体验。
 
 此次实验也让我深刻认识到网络编程的复杂性和挑战性，以及理论与实践相结合的重要性。在实际编程过程中，需要综合考虑性能、安全性、可靠性和用户体验等多个因素，才能开发出高质量的网络应用程序。
 
 \section{参考文献} 
 \label{section:references}
 
 \begin{thebibliography}{9}
 
 \bibitem{tcpip}
     谢希仁. 计算机网络（第8版）[M]. 北京：电子工业出版社，2021.
 
 \bibitem{socket}
     尹圣雨. 网络编程实战：使用C/C++开发基于TCP/IP的网络应用[M]. 北京：人民邮电出版社，2020.
 
 \bibitem{concurrency}
     王健. C++多线程编程实战[M]. 北京：清华大学出版社，2019.
 
 \bibitem{crossplatform}
     李忠伟. C++跨平台开发指南[M]. 北京：机械工业出版社，2021.
 
 \bibitem{tcp}
     RFC 793. Transmission Control Protocol[S]. 1981.
 
 \end{thebibliography}
 
 \appendix
 \section{附录A：完整源代码} 
 \label{appendix:a}
 
 由于篇幅限制，本附录仅列出关键代码片段。完整源代码请参考项目文件：
 \begin{itemize}
     \item client.cpp：客户端完整代码
     \item server.cpp：服务器端完整代码
 \end{itemize}
 
 \section{附录B：相关头文件} 
 \label{appendix:b}
 
 Windows平台所需头文件：
 \begin{lstlisting}
 #include <WinSock2.h>
 #include <WS2tcpip.h>
 #include <process.h>
 #include <Windows.h>
 
 #pragma comment(lib, "ws2_32.lib")
 \end{lstlisting}
 
 Linux平台所需头文件：
 \begin{lstlisting}
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <unistd.h>
 #include <pthread.h>
 #include <cstring>
 \end{lstlisting}
 
 \section{附录C：实验环境配置} 
 \label{appendix:c}
 
 本实验在以下环境中开发和测试：
 \begin{enumerate}
     \item Windows 10/11操作系统，Visual Studio 2022或MinGW编译器
     \item Linux操作系统（Ubuntu 20.04 LTS），GCC/G++编译器
     \item C++11及以上标准
     \item 网络环境：本地局域网或互联网（确保端口开放）
 \end{enumerate}
 
 \end{document}